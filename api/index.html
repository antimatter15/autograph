<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>autograph</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">autograph</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> autograph</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#autograph" id="autograph" style="color: inherit; text-decoration: none;">
					<h1>Autograph</h1>
				</a>
				<p><a href="https://circleci.com/gh/antimatter15/autograph/tree/master"><img src="https://circleci.com/gh/antimatter15/autograph/tree/master.svg?style=shield&circle-token=9cf70317fa05c1ddefda8f8e4a8e626270c982a3" alt="CircleCI"></a> <a href="https://codecov.io/gh/antimatter15/autograph"><img src="https://codecov.io/gh/antimatter15/autograph/branch/master/graph/badge.svg?token=aTFUP1oXXe" alt="codecov"></a></p>
				<p>Using GraphQL is often quite repetitive and repetitive. You have to declare your schemas, implement your resolvers, write your queries, and destructure the results of your queries. You end up writing the same thing in different forms several times, each time using slightly different syntax. Here&#39;s what it looks like to use Apollo to query a server for some basic information about currencies:</p>
				<pre><code class="language-jsx">&lt;Query
    query={gql<span class="hljs-string">`
    {
        rates(currency: "USD") {
            currency
            rate
        }
    }
    `</span>}
&gt;
    {({ loading, error, data }) =&gt; {
        <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
        <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Error :(<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;

        <span class="hljs-keyword">return</span> data.rates.map(<span class="hljs-function">(<span class="hljs-params">{ currency, rate }</span>) =&gt;</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{`${currency}: ${rate}`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        ));
    }}
&lt;<span class="hljs-regexp">/Query&gt;</span></code></pre>
				<p>Autograph is a new kind of GraphQL client that eliminates some of that repetition. Here&#39;s some code which does the same thing as the code above, using Autograph:</p>
				<pre><code class="language-jsx">&lt;Autograph&gt;{
    (Query: GQL.Query) =&gt; Query.rates({ <span class="hljs-attr">currency</span>: <span class="hljs-string">"USD"</span> }).map(<span class="hljs-function">(<span class="hljs-params">{ currency, rate }</span>) =&gt;</span> 
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{currency}: {rate}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
}&lt;<span class="hljs-regexp">/Autograph&gt;</span></code></pre>
				<p>At runtime, Autograph will automatically generate the following GraphQL query, which fetches all of the data needed to render the component in a single request, requesting only the fields that you actually use. </p>
				<pre><code class="language-graphql">query {
    rates(currency: &quot;USD&quot;) {
        currency
        rate
    }
}</code></pre>
				<p>It doesn&#39;t require any compilation plugins— so you don&#39;t have to worry about messing up your precariously functional <code>.babelrc</code>. You can use it with Webpack, Babel, Parcel, Next.JS, or even plain Javascript. </p>
				<p>That said, things get even better if you write your app in Typescript. Autograph can import a GraphQL schema and automatically generate a Typescript definition file, so that your editor can autocomplete fields in GraphQL while providing inline documentation, and your typechecker can ensure that all your UI code fits the data access schema. </p>
				<a href="#how-it-works" id="how-it-works" style="color: inherit; text-decoration: none;">
					<h2>How It Works</h2>
				</a>
				<p>You might ask, how does this sorcery work? It&#39;s actually quite simple. We render your component twice— the first time, instead of threading in actual data through the <code>Query</code> object, we pass in a special object that we dynamically construct using the GraphQL schema. This object has methods and getters defined in all the right places that all output fake data. Whenever any field of the object gets accessed, it records the path of the data that was requested. At the end of the special rendering pass, all the paths are added up, and we generate the exact GraphQL query that fetches all the right data. Now it&#39;s just a simple matter of feeding the real data into your render function by calling it one last time.</p>
				<p>Since React rendering functions typically have no side effects, most of the time things should just work. You can even pass the <code>Query</code> object or any of its descendents as a prop to other components, and it&#39;ll still do the right thing. It does have a few gotchas though— most notably, if there&#39;s any code path that accesses data which doesn&#39;t get called during the scouting phase, Autograph won&#39;t know to fetch that data. </p>
				<a href="#mutations" id="mutations" style="color: inherit; text-decoration: none;">
					<h2>Mutations</h2>
				</a>
				<p>So we&#39;ve seen Autograph for running queries, but what about for running mutations and updating a form on your site? </p>
				<pre><code class="language-jsx"><span class="hljs-keyword">const</span> doMutation = MakeMutation(<span class="hljs-string">"Your GraphQL Endpoint"</span>)
<span class="hljs-keyword">await</span> doMutation(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> 
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Review</span> <span class="hljs-attr">review</span>=<span class="hljs-string">{mutation.UpdateReview({</span> 
        <span class="hljs-attr">id:</span> <span class="hljs-attr">ReviewID</span>, 
        <span class="hljs-attr">review:</span> {
            <span class="hljs-attr">author:</span> '<span class="hljs-attr">Rodger</span> <span class="hljs-attr">Qbert</span>',
            <span class="hljs-attr">title:</span> '<span class="hljs-attr">A</span> <span class="hljs-attr">Midwinter</span> <span class="hljs-attr">Days</span> <span class="hljs-attr">Trip</span>',
            <span class="hljs-attr">rating:</span> <span class="hljs-attr">3</span>
        }
    })} /&gt;</span>
)</span></code></pre>
				<p>Here we use a <code>MakeMutation</code> which returns a function that you can call with another function. You can pretend that it&#39;s just a Javascript object containing all your mutations, so you can any of its methods as ordinary functions. Our <code>UpdateReview</code> method here returns the updated <code>Review</code> instance with the changed fields, but we&#39;ll somehow need to signal what fields we&#39;re interested in fetching. The simple thing we can do is just pass the result of the mutation into the React component which typically renders <code>Review</code> objects. This will allow Autograph to figure out exactly what fields needs to be pulled. </p>
				<p>When these updated fields are pulled, the underlying GraphQL caching engine can notice this and update all the appropriate components on the page. </p>
				<p>What if you don&#39;t want to deal with React components at all? That&#39;s fine, the <code>doMutation</code> method (and as you might expect there&#39;s an almost identical <code>doQuery</code> method) doesn&#39;t care what you do with it— it just passes the finished result back through. </p>
				<pre><code class="language-jsx"><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> doQuery(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span>: query.me.name,
        <span class="hljs-attr">numberOfFriends</span>: query.me.friends.length
    }
})
<span class="hljs-comment">// data = { name: 'Bob Smitterjensen', numberOfFriends: 3 }</span></code></pre>
				<p>Notes: The automatic reloading of affected components requires an underlying GraphQL caching layer such as Apollo. </p>
				<a href="#loadingerror-status" id="loadingerror-status" style="color: inherit; text-decoration: none;">
					<h2>Loading/Error Status</h2>
				</a>
				<p>With Apollo, you need to explicitly define your error and loading handlers, or else your component will fail to render when <code>data</code> is null or undefined. </p>
				<p>Autograph provides default renderers for both loading states and error states, so it&#39;s as easy as possible to get things up and running. But it&#39;s also really easy to add explicit error and loading handlers.</p>
				<pre><code class="language-jsx">&lt;Autograph&gt;{
    (Query: GQL.Query) =&gt; {
        <span class="hljs-keyword">if</span>(Query.__loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        <span class="hljs-keyword">if</span>(Query.__error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Found some errors... {Query.__error}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        <span class="hljs-keyword">return</span> Query.rates({ <span class="hljs-attr">currency</span>: <span class="hljs-string">"USD"</span> }).map(<span class="hljs-function">(<span class="hljs-params">{ currency, rate }</span>) =&gt;</span> 
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{currency}: {rate}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
}&lt;<span class="hljs-regexp">/Autograph&gt;</span></code></pre>
				<p>When doing the rendering dry-run, Autograph checks to see whether or not your code reads a value from <code>__loading</code> or <code>__error</code>. Then when data is being loaded (or if an error occurs), it knows that it should call the rendering function (instead of falling back to the default handler). </p>
				<a href="#higher-order-component" id="higher-order-component" style="color: inherit; text-decoration: none;">
					<h2>Higher Order Component</h2>
				</a>
				<p>Don&#39;t want to wrap your components in a render prop? We also have a higher order component which will automatically inject <code>Query</code> as a prop to your component.</p>
				<pre><code class="language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">{ Query }</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My Pokemons<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        {Query.pokemons({ first: 20 }).map(k =&gt; 
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{k.id}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">PokemonSummary</span> <span class="hljs-attr">pokemon</span>=<span class="hljs-string">{k}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}

export default withAutograph(App)</span></code></pre>
				<a href="#react-suspense" id="react-suspense" style="color: inherit; text-decoration: none;">
					<h2>React Suspense</h2>
				</a>
				<p>React 16.6.0 includes a feature called Suspense, which allows a component to suspend rendering by throwing a promise within its render function. This can be used to easily handle and display different loading states, while providing slick user experiences without extraneous loading spinners.</p>
				<p>Autograph can be told to fetch data this way simply by adding <code>suspense</code> as an argument. </p>
				<pre><code class="language-jsx">&lt;Autograph suspense&gt;{
    Query =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{
        Query.me.friends({ limit: 50 }).map(friend =&gt; 
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{friend.id}</span>&gt;</span>{friend.name} ({friend.mutuals.length} mutual friends)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )
    }<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}&lt;<span class="hljs-regexp">/Autograph&gt;</span></code></pre>
				<p>Just as <code>suspense</code> make it so that loading states are handled by suspense placeholder boundaries, <code>throw</code> can be passed as a prop if you want data fetching errors to be handled by error boundaries. </p>
				<a href="#server-side--universal-rendering" id="server-side--universal-rendering" style="color: inherit; text-decoration: none;">
					<h2>Server Side / Universal Rendering</h2>
				</a>
				<p>With an SSR framework such as Next.JS, it&#39;s easy to add isomorphic GraphQL rendering with Autograph. A <code>getDataFromTree</code> method can do a simulated render pass of the entire component tree to determine the necessary GraphQL queries to run and to fetch them all in one request that can then be rendered with <code>renderToString</code>. On top of that the data can get serialized and sent to the client for hydration and use within interactive components. </p>
				<pre><code class="language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ({ Query, ctx }: { <span class="hljs-attr">Query</span>: GQL.Query, ctx }) =&gt; {
    <span class="hljs-keyword">let</span> pokemon = Query.pokemon({ <span class="hljs-attr">id</span>: ctx.query.id })
    <span class="hljs-keyword">return</span> &lt;div&gt;
        &lt;Link href="/"&gt;&lt;a&gt;&amp;larr; Back&lt;/a&gt;&lt;/Link&gt;
        &lt;h1&gt;{pokemon.name}&lt;/h1&gt;
        &lt;i&gt;{ctx.query.id}&lt;/i&gt;
        &lt;div&gt;&lt;img src={pokemon.image} /&gt;&lt;/div&gt;
        &lt;div&gt;{pokemon.types.map(k =&gt; &lt;li key={k}&gt;{k}&lt;/li&gt;)}&lt;/div&gt;
        &lt;fieldset&gt;
            &lt;legend&gt;Evolutions:&lt;/legend&gt;
            {(pokemon.evolutions || []).map(k =&gt; &lt;div key={k.id}&gt;
                &lt;PokemonSummary pokemon={k} /&gt;
            &lt;/div&gt;)}
        &lt;/fieldset&gt;
    &lt;/div&gt;
}</code></pre>
				<a href="#a-sneak-peek-into-the-depths-of-madness" id="a-sneak-peek-into-the-depths-of-madness" style="color: inherit; text-decoration: none;">
					<h2>A sneak peek into the depths of madness</h2>
				</a>
				<p>React recently announced their new Hooks API, which provides new APIs like <code>useState</code>, <code>useEffects</code>, and <code>useContext</code> which are accessible in functional components— no need to use render props, or to thread data through props. </p>
				<p>In a similar vein we&#39;ve prototyped <code>useQuery</code>. You&#39;d pass in a reference to the current function and props, and it&#39;ll return a query object that you can synchronously use as if all the data on your server has already been loaded. </p>
				<pre><code class="language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">props</span>)</span>{
    <span class="hljs-keyword">let</span> query: GQL.Query = useQuery(App, props)
    <span class="hljs-keyword">let</span> block = query.block({ <span class="hljs-attr">number</span>: <span class="hljs-number">5450945</span> })

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Block {block.hash}<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Miner<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{block.miner.address}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Number<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{block.number}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
        {block.transactions({ filter: { withInput: false }})
            .map(tx =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{tx.hash}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>{tx.index}: {tx.hash}<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>From<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{tx.from.address}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>To<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{tx.to.address}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span>)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span>
}</code></pre>
				<p>When <code>useQuery</code> is called from a base reality, it simulates in invocation of the calling function. The base reality call to <code>useQuery</code> coordinates with the copy of itself existing in the simulation, and returns a sentinel in the simulated case. The simulation of the parent function continues to run, which in turn monitors how the sentinel gets used and passed around. Once the simulation is finished, the base reality <code>useQuery</code> call compiles all that information together and generates a GraphQL query that fetches all the information needed to render the component. It checks to see if the data has been loaded into the cache, and if not, it begins the process of fetching the data and throws a promise that resolves when the data is loaded. This promise is caught by React Suspense, which then tries again to render the the component when the promise resolves, in turn restarting the whole <code>useQuery</code> nightmare.  </p>
				<p>In a sense it&#39;s simliar to John McCarthy&#39;s <code>amb</code> operator found in some variants of Lisp. It&#39;s a function ostensibly looks into the future in order to know what to return. </p>
				<p>Note that using this API requires React Suspense, and throws errors when data fetching fails— so your app will need to be wrapped with both a suspense placeholder and an error boundary. For the current prototype, it can only be used within stateless functional components. Also it is likely not possible for this API to be used in conjunction with <code>useState</code> hooks.</p>
				<a href="#browser-support" id="browser-support" style="color: inherit; text-decoration: none;">
					<h2>Browser Support</h2>
				</a>
				<p>Autograph supports all browsers that React supports (IE9+). </p>
				<p>The only special Javascript feature that it uses is the ability to define getters for objects, which is widely supported in all modern browsers. </p>
				<a href="#caveats" id="caveats" style="color: inherit; text-decoration: none;">
					<h2>Caveats</h2>
				</a>
				<p>You might say that all of this looks pretty neat, but what if I want to do something stateful? What if I want to run a query and call some sort of external method with the results, without having to worry about a phantom scouting phase that feeds fake data? Conveniently every fake object in the initial phase includes a <code>__dryRun</code> field, which you can use to guard stateful calls. </p>
				<pre><code class="language-jsx"><span class="hljs-keyword">await</span> doQuery(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> {
    _.uniqBy(query.me.favoriteBooks
        .map(<span class="hljs-function"><span class="hljs-params">book</span> =&gt;</span> book.author),
        author =&gt; author.name
    ).forEach(<span class="hljs-function"><span class="hljs-params">author</span> =&gt;</span> {
        skipIf(query.__dryRun, drawAuthor)({
            <span class="hljs-attr">name</span>: author.name,
            <span class="hljs-attr">image</span>: author.image,
            <span class="hljs-attr">books</span>: author.books.length
        })
    })
})</code></pre>
				<p>We&#39;ve included a helper method <code>skipIf(shouldSkip: boolean, fn: function)</code> which you can use to easily substitute a function for a dummy function (you shouldn&#39;t use if statements because then Autograph won&#39;t know which fields are needed to run the query when it&#39;s actually time to call the function). </p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/___tests___accessor_.html">"__tests__/accessor"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/___tests___graphql_.html">"__tests__/graphql"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/___tests___typescript_.html">"__tests__/typescript"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_accessor_.html">"accessor"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_autograph_.html">"autograph"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_dryrender___tests___context_.html">"dryrender/__tests__/context"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_dryrender___tests___hooks_.html">"dryrender/__tests__/hooks"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_dryrender___tests___hydra_.html">"dryrender/__tests__/hydra"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_dryrender___tests___lazy_.html">"dryrender/__tests__/lazy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_dryrender___tests___traversal_.html">"dryrender/__tests__/traversal"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_dryrender_dryrender_.html">"dryrender/dryrender"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_graphql_.html">"graphql"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_typescript_.html">"typescript"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util___tests___eager_.html">"util/__tests__/eager"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util___tests___fixarray_.html">"util/__tests__/fixarray"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util___tests___util_.html">"util/__tests__/util"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util_eager_.html">"util/eager"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util_fixarray_.html">"util/fixarray"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util_util_.html">"util/util"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>