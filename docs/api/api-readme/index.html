<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>autograph · Autograph</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;autograph&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#autograph&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Autograph&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="autograph · Autograph"/><meta property="og:type" content="website"/><meta property="og:url" content="https://autograph.dev//"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;autograph&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#autograph&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Autograph&lt;/h1&gt;
"/><meta property="og:image" content="https://autograph.dev/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://autograph.dev/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://autograph.dev/blog/atom.xml" title="Autograph Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://autograph.dev/blog/feed.xml" title="Autograph Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="Autograph"/><h2 class="headerTitleWithLogo">Autograph</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/evolution" target="_self">Getting Started</a></li><li class=""><a href="/docs/api" target="_self">API</a></li><li class=""><a href="/help" target="_self">Help</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">autograph</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="autograph"></a><a href="#autograph" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Autograph</h1>
<p><a href="https://circleci.com/gh/antimatter15/autograph/tree/master"><img src="https://circleci.com/gh/antimatter15/autograph/tree/master.svg?style=shield&amp;circle-token=9cf70317fa05c1ddefda8f8e4a8e626270c982a3" alt="CircleCI"></a> <a href="https://codecov.io/gh/antimatter15/autograph"><img src="https://codecov.io/gh/antimatter15/autograph/branch/master/graph/badge.svg?token=aTFUP1oXXe" alt="codecov"></a></p>
<p>Using GraphQL is often quite repetitive and repetitive. You have to declare your schemas, implement your resolvers, write your queries, and destructure the results of your queries. You end up writing the same thing in different forms several times, each time using slightly different syntax. Here's what it looks like to use Apollo to query a server for some basic information about currencies:</p>
<pre><code class="hljs css language-jsx">&lt;Query
    query={gql`
    {
        rates(currency: "USD") {
            currency
            rate
        }
    }
    `}
&gt;
    {({ loading, error, data }) =&gt; {
        if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
        if (error) return &lt;p&gt;Error :(&lt;/p&gt;;

        return data.rates.map(({ currency, rate }) =&gt; (
            &lt;div key={currency}&gt;
                &lt;p&gt;{`${currency}: ${rate}`}&lt;/p&gt;
            &lt;/div&gt;
        ));
    }}
&lt;/Query&gt;
</code></pre>
<p>Autograph is a new kind of GraphQL client that eliminates some of that repetition. Here's some code which does the same thing as the code above, using Autograph:</p>
<pre><code class="hljs css language-jsx">&lt;Autograph&gt;{
    (Query: GQL.Query) =&gt; Query.rates({ currency: "USD" }).map(({ currency, rate }) =&gt; 
        &lt;div key={currency}&gt;
            &lt;p&gt;{currency}: {rate}&lt;/p&gt;
        &lt;/div&gt;
    )
}&lt;/Autograph&gt;
</code></pre>
<p>At runtime, Autograph will automatically generate the following GraphQL query, which fetches all of the data needed to render the component in a single request, requesting only the fields that you actually use.</p>
<pre><code class="hljs css language-graphql"><span class="hljs-selector-tag">query</span> {
    <span class="hljs-selector-tag">rates</span>(<span class="hljs-attribute">currency</span>: <span class="hljs-string">"USD"</span>) {
        <span class="hljs-selector-tag">currency</span>
        <span class="hljs-selector-tag">rate</span>
    }
}
</code></pre>
<p>It doesn't require any compilation plugins— so you don't have to worry about messing up your precariously functional <code>.babelrc</code>. You can use it with Webpack, Babel, Parcel, Next.JS, or even plain Javascript.</p>
<p>That said, things get even better if you write your app in Typescript. Autograph can import a GraphQL schema and automatically generate a Typescript definition file, so that your editor can autocomplete fields in GraphQL while providing inline documentation, and your typechecker can ensure that all your UI code fits the data access schema.</p>
<h2><a class="anchor" aria-hidden="true" id="how-it-works"></a><a href="#how-it-works" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How It Works</h2>
<p>You might ask, how does this sorcery work? It's actually quite simple. We render your component twice— the first time, instead of threading in actual data through the <code>Query</code> object, we pass in a special object that we dynamically construct using the GraphQL schema. This object has methods and getters defined in all the right places that all output fake data. Whenever any field of the object gets accessed, it records the path of the data that was requested. At the end of the special rendering pass, all the paths are added up, and we generate the exact GraphQL query that fetches all the right data. Now it's just a simple matter of feeding the real data into your render function by calling it one last time.</p>
<p>Since React rendering functions typically have no side effects, most of the time things should just work. You can even pass the <code>Query</code> object or any of its descendents as a prop to other components, and it'll still do the right thing. It does have a few gotchas though— most notably, if there's any code path that accesses data which doesn't get called during the scouting phase, Autograph won't know to fetch that data.</p>
<h2><a class="anchor" aria-hidden="true" id="mutations"></a><a href="#mutations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutations</h2>
<p>So we've seen Autograph for running queries, but what about for running mutations and updating a form on your site?</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">const</span> doMutation = MakeMutation(<span class="hljs-string">"Your GraphQL Endpoint"</span>)
<span class="hljs-keyword">await</span> doMutation(<span class="hljs-function"><span class="hljs-params">mutation</span> =&gt;</span> 
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Review</span> <span class="hljs-attr">review</span>=<span class="hljs-string">{mutation.UpdateReview({</span> 
        <span class="hljs-attr">id:</span> <span class="hljs-attr">ReviewID</span>, 
        <span class="hljs-attr">review:</span> {
            <span class="hljs-attr">author:</span> '<span class="hljs-attr">Rodger</span> <span class="hljs-attr">Qbert</span>',
            <span class="hljs-attr">title:</span> '<span class="hljs-attr">A</span> <span class="hljs-attr">Midwinter</span> <span class="hljs-attr">Days</span> <span class="hljs-attr">Trip</span>',
            <span class="hljs-attr">rating:</span> <span class="hljs-attr">3</span>
        }
    })} /&gt;</span>
)
</span></code></pre>
<p>Here we use a <code>MakeMutation</code> which returns a function that you can call with another function. You can pretend that it's just a Javascript object containing all your mutations, so you can any of its methods as ordinary functions. Our <code>UpdateReview</code> method here returns the updated <code>Review</code> instance with the changed fields, but we'll somehow need to signal what fields we're interested in fetching. The simple thing we can do is just pass the result of the mutation into the React component which typically renders <code>Review</code> objects. This will allow Autograph to figure out exactly what fields needs to be pulled.</p>
<p>When these updated fields are pulled, the underlying GraphQL caching engine can notice this and update all the appropriate components on the page.</p>
<p>What if you don't want to deal with React components at all? That's fine, the <code>doMutation</code> method (and as you might expect there's an almost identical <code>doQuery</code> method) doesn't care what you do with it— it just passes the finished result back through.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> doQuery(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span>: query.me.name,
        <span class="hljs-attr">numberOfFriends</span>: query.me.friends.length
    }
})
<span class="hljs-comment">// data = { name: 'Bob Smitterjensen', numberOfFriends: 3 }</span>
</code></pre>
<p>Notes: The automatic reloading of affected components requires an underlying GraphQL caching layer such as Apollo.</p>
<h2><a class="anchor" aria-hidden="true" id="loading-error-status"></a><a href="#loading-error-status" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading/Error Status</h2>
<p>With Apollo, you need to explicitly define your error and loading handlers, or else your component will fail to render when <code>data</code> is null or undefined.</p>
<p>Autograph provides default renderers for both loading states and error states, so it's as easy as possible to get things up and running. But it's also really easy to add explicit error and loading handlers.</p>
<pre><code class="hljs css language-jsx">&lt;Autograph&gt;{
    (Query: GQL.Query) =&gt; {
        if(Query.__loading) return &lt;div&gt;Loading...&lt;/div&gt;
        if(Query.__error) return &lt;div&gt;Found some errors... {Query.__error}&lt;/div&gt;
        return Query.rates({ currency: "USD" }).map(({ currency, rate }) =&gt; 
            &lt;div key={currency}&gt;
                &lt;p&gt;{currency}: {rate}&lt;/p&gt;
            &lt;/div&gt;
        )
    }
}&lt;/Autograph&gt;
</code></pre>
<p>When doing the rendering dry-run, Autograph checks to see whether or not your code reads a value from <code>__loading</code> or <code>__error</code>. Then when data is being loaded (or if an error occurs), it knows that it should call the rendering function (instead of falling back to the default handler).</p>
<h2><a class="anchor" aria-hidden="true" id="higher-order-component"></a><a href="#higher-order-component" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Higher Order Component</h2>
<p>Don't want to wrap your components in a render prop? We also have a higher order component which will automatically inject <code>Query</code> as a prop to your component.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">{ Query }</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My Pokemons<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        {Query.pokemons({ first: 20 }).map(k =&gt; 
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{k.id}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">PokemonSummary</span> <span class="hljs-attr">pokemon</span>=<span class="hljs-string">{k}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}

export default withAutograph(App)
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" id="react-suspense"></a><a href="#react-suspense" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React Suspense</h2>
<p>React 16.6.0 includes a feature called Suspense, which allows a component to suspend rendering by throwing a promise within its render function. This can be used to easily handle and display different loading states, while providing slick user experiences without extraneous loading spinners.</p>
<p>Autograph can be told to fetch data this way simply by adding <code>suspense</code> as an argument.</p>
<pre><code class="hljs css language-jsx">&lt;Autograph suspense&gt;{
    Query =&gt; &lt;div&gt;{
        Query.me.friends({ limit: 50 }).map(friend =&gt; 
            &lt;div key={friend.id}&gt;{friend.name} ({friend.mutuals.length} mutual friends)&lt;/div&gt;
        )
    }&lt;/div&gt;
}&lt;/Autograph&gt;
</code></pre>
<p>Just as <code>suspense</code> make it so that loading states are handled by suspense placeholder boundaries, <code>throw</code> can be passed as a prop if you want data fetching errors to be handled by error boundaries.</p>
<h2><a class="anchor" aria-hidden="true" id="server-side-universal-rendering"></a><a href="#server-side-universal-rendering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Server Side / Universal Rendering</h2>
<p>With an SSR framework such as Next.JS, it's easy to add isomorphic GraphQL rendering with Autograph. A <code>getDataFromTree</code> method can do a simulated render pass of the entire component tree to determine the necessary GraphQL queries to run and to fetch them all in one request that can then be rendered with <code>renderToString</code>. On top of that the data can get serialized and sent to the client for hydration and use within interactive components.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ({ Query, ctx }: { <span class="hljs-attr">Query</span>: GQL.Query, ctx }) =&gt; {
    <span class="hljs-keyword">let</span> pokemon = Query.pokemon({ <span class="hljs-attr">id</span>: ctx.query.id })
    <span class="hljs-keyword">return</span> &lt;div&gt;
        &lt;Link href="/"&gt;&lt;a&gt;&amp;larr; Back&lt;/a&gt;&lt;/Link&gt;
        &lt;h1&gt;{pokemon.name}&lt;/h1&gt;
        &lt;i&gt;{ctx.query.id}&lt;/i&gt;
        &lt;div&gt;&lt;img src={pokemon.image} /&gt;&lt;/div&gt;
        &lt;div&gt;{pokemon.types.map(k =&gt; &lt;li key={k}&gt;{k}&lt;/li&gt;)}&lt;/div&gt;
        &lt;fieldset&gt;
            &lt;legend&gt;Evolutions:&lt;/legend&gt;
            {(pokemon.evolutions || []).map(k =&gt; &lt;div key={k.id}&gt;
                &lt;PokemonSummary pokemon={k} /&gt;
            &lt;/div&gt;)}
        &lt;/fieldset&gt;
    &lt;/div&gt;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="a-sneak-peek-into-the-depths-of-madness"></a><a href="#a-sneak-peek-into-the-depths-of-madness" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A sneak peek into the depths of madness</h2>
<p>React recently announced their new Hooks API, which provides new APIs like <code>useState</code>, <code>useEffects</code>, and <code>useContext</code> which are accessible in functional components— no need to use render props, or to thread data through props.</p>
<p>In a similar vein we've prototyped <code>useQuery</code>. You'd pass in a reference to the current function and props, and it'll return a query object that you can synchronously use as if all the data on your server has already been loaded.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">props</span>)</span>{
    <span class="hljs-keyword">let</span> query: GQL.Query = useQuery(App, props)
    <span class="hljs-keyword">let</span> block = query.block({ <span class="hljs-attr">number</span>: <span class="hljs-number">5450945</span> })

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Block {block.hash}<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Miner<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{block.miner.address}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Number<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{block.number}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
        {block.transactions({ filter: { withInput: false }})
            .map(tx =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{tx.hash}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>{tx.index}: {tx.hash}<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>From<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{tx.from.address}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>To<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{tx.to.address}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span>)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span>
}
</code></pre>
<p>When <code>useQuery</code> is called from a base reality, it simulates in invocation of the calling function. The base reality call to <code>useQuery</code> coordinates with the copy of itself existing in the simulation, and returns a sentinel in the simulated case. The simulation of the parent function continues to run, which in turn monitors how the sentinel gets used and passed around. Once the simulation is finished, the base reality <code>useQuery</code> call compiles all that information together and generates a GraphQL query that fetches all the information needed to render the component. It checks to see if the data has been loaded into the cache, and if not, it begins the process of fetching the data and throws a promise that resolves when the data is loaded. This promise is caught by React Suspense, which then tries again to render the the component when the promise resolves, in turn restarting the whole <code>useQuery</code> nightmare.</p>
<p>In a sense it's simliar to John McCarthy's <code>amb</code> operator found in some variants of Lisp. It's a function ostensibly looks into the future in order to know what to return.</p>
<p>Note that using this API requires React Suspense, and throws errors when data fetching fails— so your app will need to be wrapped with both a suspense placeholder and an error boundary. For the current prototype, it can only be used within stateless functional components. Also it is likely not possible for this API to be used in conjunction with <code>useState</code> hooks.</p>
<h2><a class="anchor" aria-hidden="true" id="browser-support"></a><a href="#browser-support" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Browser Support</h2>
<p>Autograph supports all browsers that React supports (IE9+).</p>
<p>The only special Javascript feature that it uses is the ability to define getters for objects, which is widely supported in all modern browsers.</p>
<h2><a class="anchor" aria-hidden="true" id="caveats"></a><a href="#caveats" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caveats</h2>
<p>You might say that all of this looks pretty neat, but what if I want to do something stateful? What if I want to run a query and call some sort of external method with the results, without having to worry about a phantom scouting phase that feeds fake data? Conveniently every fake object in the initial phase includes a <code>__dryRun</code> field, which you can use to guard stateful calls.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">await</span> doQuery(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> {
    _.uniqBy(query.me.favoriteBooks
        .map(<span class="hljs-function"><span class="hljs-params">book</span> =&gt;</span> book.author),
        author =&gt; author.name
    ).forEach(<span class="hljs-function"><span class="hljs-params">author</span> =&gt;</span> {
        skipIf(query.__dryRun, drawAuthor)({
            <span class="hljs-attr">name</span>: author.name,
            <span class="hljs-attr">image</span>: author.image,
            <span class="hljs-attr">books</span>: author.books.length
        })
    })
})
</code></pre>
<p>We've included a helper method <code>skipIf(shouldSkip: boolean, fn: function)</code> which you can use to easily substitute a function for a dummy function (you shouldn't use if statements because then Autograph won't know which fields are needed to run the query when it's actually time to call the function).</p>
<h3><a class="anchor" aria-hidden="true" id="external-modules"></a><a href="#external-modules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>External modules</h3>
<ul>
<li><a href="/docs/api/api-modules---tests---typescript-module">[<strong>tests</strong>/typescript Module]</a></li>
<li><a href="/docs/api/api-modules-autograph-module">[autograph Module]</a></li>
<li><a href="/docs/api/api-modules-dryrender---tests---lazy-module">[dryrender/<strong>tests</strong>/lazy Module]</a></li>
<li><a href="/docs/api/api-modules-dryrender-dryrender-module">[dryrender/dryrender Module]</a></li>
<li><a href="/docs/api/api-modules-graphql-module">[graphql Module]</a></li>
<li><a href="/docs/api/api-modules-typescript-module">[typescript Module]</a></li>
<li><a href="/docs/api/api-modules-util-fixarray-module">[util/fixarray Module]</a></li>
<li><a href="/docs/api/api-modules-util-util-module">[util/util Module]</a></li>
</ul>
<hr>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#how-it-works">How It Works</a></li><li><a href="#mutations">Mutations</a></li><li><a href="#loading-error-status">Loading/Error Status</a></li><li><a href="#higher-order-component">Higher Order Component</a></li><li><a href="#react-suspense">React Suspense</a></li><li><a href="#server-side-universal-rendering">Server Side / Universal Rendering</a></li><li><a href="#a-sneak-peek-into-the-depths-of-madness">A sneak peek into the depths of madness</a></li><li><a href="#browser-support">Browser Support</a></li><li><a href="#caveats">Caveats</a><ul class="toc-headings"><li><a href="#external-modules">External modules</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/favicon.ico" alt="Autograph" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 Kevin Kwok (antimatter15@gmail.com)</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '54be4fd9951c5488782ff92be33d9861',
                indexName: 'autograph',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>